## Goals

-   Define authentication and authorization
-   Define hashing
-   Learn about Bcrypt
-   Implement authentication/authorization in Flask

## Registering and logging in

### Authentication & authorization

- Authentication
	- Has user presented valid credentials (eg, username/password)?
	- *Are you who you say you are?*
	- Usually site-wide
- Authorization
	- Is the user allowed to perform this task?
	- *Are you allowed to do this?*
	- Usually more micro-checked - some areas able to edit, others just view
- Different people usually work on these areas separately, helpful to think of as two separate ideas.

-   Sometimes, there’s no authentication and everyone is authorized
    -   eg, a public site with no user accounts or security
-   On many sites, you authenticate and some actions are authorized
    -   eg, New York Times: you must log in to prove you’re a subscriber
    -   … but only editors get to add/change articles

-   You log in with a username/password
-   The site _authenticates_ those to see if they’re valid
-   It remembers that you’re valid and logged in *(often via session)*
	- & This works because sessions are *signed*. Can’t just manually created a cookie - that cookie has to have the valid signature of that user as generated by the server.
-   When you visit “protected routes”, it checks if you’re _authorized_

### User class - Non-example

demo/bad_password/models.py
```python
class BadUser(db.Model):
    """Site user."""

    __tablename__ = "bad_users"

    id = db.Column(
        db.Integer,
        primary_key=True,
        autoincrement=True)

    username = db.Column(
        db.Text,
        nullable=False,
        unique=True)

    password = db.Column(
        db.Text,
        nullable=False)
```

demo/bad_password/app.py
```python
@app.route("/register", methods=["GET", "POST"])
def register():
    """Register user: produce form & handle form submission."""

    form = RegisterForm()

    if form.validate_on_submit():
        name = form.username.data
        pwd = form.password.data

        user = BadUser(username=name, password=pwd)
        db.session.add(user)
        db.session.commit()

        # on successful login, redirect to secret page
        return redirect("/secret")

    else:
        return render_template("register.html", form=form)
```

demo/bad_password/app.py
```python
@app.route("/login", methods=["GET", "POST"])
def login():
    """Produce login form or handle login."""

    form = LoginForm()

    if form.validate_on_submit():
        name = form.username.data
        pwd = form.password.data

        user = BadUser.query.filter_by(username=name).one_or_none()

        if user and user.password == pwd:
            # on successful login, redirect to secret page
            return redirect("/secret")

        else:
            # re-render the login page with an error
            form.username.errors = ["Bad name/password"]

    return render_template("login.html", form=form)

```

```sql
SELECT * FROM bad_users; 
```
| username | password |
| --- | --- |
| rita | squid-13 |
| roger | meeples4ever |

- !! Ut oh.  BAD practice - DO NOT STORE UNENCRYPTED (plaintext) PASSWORDS IN DB
- !! Opens security risk for unauthorized access to your site *and* other sites, since people tend to use the same password for multiple sites.

### Plaintext passwords

-   Access to database allows access to all passwords!
-   People use same passwords for multiple sites
- !!  Don’t ever do this! [Useful discussion](https://stackoverflow.com/questions/2283937/) about this

## Hashing

- **Hashing** performs a one-way transformation on a password.
	- “One-way” means it is effectively impossible to reverse.
	- “One-way encryption”
	- Contrast this with encryption - which is 2-way (can encrypt/scramble message, and then descramble/unencrypt it)
- **Hashing** is **stable** = Same input provides the same output
	- Note this difference between **stable** and **idempotent**:
		- **Stable**: Same input → Same output
		- **Idempotent**: No matter how many times you do it, its as if you did it just once.
![_images/hash-flow.png|500](https://rithm-students-assets.s3.amazonaws.com/r30/lectures/flask-hashing-login/handout/_images/hash-flow.png)

demo/bad_hash.py
```python
def awful_hash(phrase):
    """Truly terrible hash:
        simply shifts each letter (a->b, etc).

        >>> awful_hash('yay')
        'zbz'
    """

    return ''.join(next_char(c) for c in phrase)

```

- But is that really one-way?
	- This technically meets the definition of a hash, but is <u>terrible</u> and really easy to unscramble.

### One-Way encryption

demo/bad_hash.py
```python
def slightly_better_hash(phrase):
    """Better hash: returns every other letter, shifted, max 4.

        >>> slightly_better_hash('penguin1')
        'qovo'

    Since this is "lossy", multiple inputs return same output:

        >>> slightly_better_hash('penguin1~pretzel7')
        'qovo'

        >>> slightly_better_hash('p?nguinZ')
        'qovo'
    """

    return ''.join(next_char(c) for c in phrase[0:8:2])

```
- This hash is better in that it is  **lossy**  - it loses information that makes it much harder to unscramble the original password.
- BUT - this slightly_better_hash() can still be tricked
	- different input ‘cracks the code’ - because the scramble algo just gets the next character of every other letter
```python
>>> slightly_better_hash('penguin1')
        'qovo'
>>> slightly_better_hash('pZnZuZnZ')
		'quovo'
```

#### Python’s hash

- Python has a kind of hash built-in that is somewhat better the ‘slightly_better_hash()’ example and not as good as an actual cryptographic algo
	- These type of hashes are intended to run fast, not intended for security.
```python
>>> hash('penguin1')
6678229702981429425
```

-  Python’s built in hash seeds itself randomly on startup, so the same input only returns the same output for any individual Python process. 
	- & Thus, Python’s built in hash is *not* suitable for storing in a database, even if it were designed to be cryptographically secure.

- % Salts  (Salts are an interesting idea, but not critical to understand)
	- **Salt**: a random string introduced before hashing.
	  
	  ![[hashing-login-flask-1679404952315.jpeg]]
	- Salt is usually concatenated to the password, then hashed.
	  demo/bad\_hash.py
	  ```python
	  def salting_hash(phrase, salt=None):
		"""Adds random salt; returns "salt|hash(phrase+salt)
		
        >>> 		salting_hash('hey', salt='abc')
		        'izbd|abc'
		
        >>> 		salting_hash('hey', salt='def')
		        'izeg|def'
		"""
		
		if salt is None:
			salt = str(randint(1000, 9999))
	
		hashed = slightly_better_hash(f"{phrase}|{salt}")
		return f"{hashed}|{salt}"
```
	- The same password will generate a different hash with a different salt.
	  
	- % Note: Storing Salt
		- You may have noticed that the salt is clearly visible in the hashed result.
		- This is totally fine; the application needs the salt value in order to compare passwords properly. Even if an attacker gained access to the database and saw all the salts, they would still have to reverse the hashing algorithms to get the original password, which is extremely difficult and slow.
		- You can read more about [storing salts](https://security.stackexchange.com/questions/17421/how-to-store-salt).

### Cryptographic hash

-   Non-reversible
-   Change in input changes output *unpredictably*
	- Even if you know the code and are a mathematician, you couldn’t guess the password
- How these work ‘under the hood’ are extremely specialized mathematics, not even most security officers understand how these work
![[hashing-login-flask-1679405381765.jpeg]]

### Popular algorithms

- Password Hashes are structured on purpose to be difficult problems to scale
	- Even if you have the best hardward, you can’t do 1 million checks in a second - more like 1 check per second, which makes it infeasible to take the guess a million different possibilities approach
![[hashing-login-flask-1679405418845.jpeg]]

- @ Hint: Using BCrypt by hand
```python
>>> import bcrypt   # pip install bcrypt

>>> salt = bcrypt.gensalt()
>>> salt
b'$2b$12$uYNRTDE7RrMvwDcF9f1Yyu'

>>> bcrypt.hashpw(b'secret', salt)
b'$2b$12$uYNRTDE7RrMvwDcF9f1Yyuvuu48PzANrWy88Iz3z1tRTfdXi6DlNW'
```

## Bcrypt

- There’s a nice Flask integration for Bcrypt:
```python
>>> from flask_bcrypt import Bcrypt

>>> bcrypt = Bcrypt()

>>> hash = bcrypt.generate_password_hash("secret").decode('utf8')
>>> hash
'$2b$12$s.tjeALK2I7rfI2gV27me.mkZu5IQd1Y1EBAXsbTvNExIEQcID/te'

>>> bcrypt.check_password_hash(hash, "secret")
True
```

- % Note: What’s this utf-8?
	- Bcrypt’s generate_password_hash method returns a low-level type of string called a _byte string_. Before using it or trying to store it in your database, you should convert it to the normal kind of Python string, a _unicode string_.

### Work factor

-   Bcrypt algorithm is designed to be slow
    -   Intentional, to prevent checking 1 million passwords/second
    -   But computers get faster all the time!
-   So, you can specify how many _rounds_ of encryption it should use
    -   Higher will make the algorithm slower
    -   This makes it harder for hackers to compute hashes
    -   This makes it harder for your server to compute hashes

bcrypt
```python
>>> hash = bcrypt.generate_password_hash("secret", 15).decode('utf8')
>>> hash
'$2b$15$s.xyzalk2i7rfi2gv27me.mkzu5iqd1y1ebaxsbtvnexieqcid/te'
```

- Fortunately, you don’t need to do this yourself —  flask-bcrypt bumps up the default every year or so!

### HTTPS:

- Bcrypt only hashes the password once it reaches the route.
- HTTPS adds encryption from the point the user sends the data from their computer, to the point it reaches the server. 
	- Makes it so someone can’t tap into the broadband outside their house to get their passwords.

## Flask password hashing

### Class methods

- It’s good to move logic out of views
- Let’s make convenient class methods for registering & validating

### Registering

demo/good_password/models.py
```python
class User(db.Model): # ...
    @classmethod
    def register(cls, username, pwd):
        """Register user w/hashed password & return user."""

        hashed = bcrypt.generate_password_hash(pwd).decode('utf8')

        # return instance of user w/username and hashed pwd
        return cls(username=username, password=hashed)
```

example use of register :
```python
>>> roger = User.register("roger", "cupcakes")
>>> db.session.add(roger)
>>> db.session.commit()
```

### Authenticating

demo/good_password/models.py
```python
class User(db.Model): # ...
    @classmethod
    def authenticate(cls, username, pwd):
        """Validate that user exists & password is correct.

        Return user if valid; else return False.
        """

        u = cls.query.filter_by(username=username).one_or_none()

        if u and bcrypt.check_password_hash(u.password, pwd):
            # return user instance
            return u
        else:
            return False

```
- & Important that you don’t provide information until user authenticates.
	- Notice how if the username OR password is wrong: both return false. Does not give feedback that your username is right but your password wrong, etc. This is better for user security.

example use of authenticate:
```python
>>> User.authenticate("roger", "cupcakes")
<User 3>
```

### Good-password Result

![[hashing-login-flask-1679406876592.jpeg]]
Encrypted! ![🎉|25](https://twemoji.maxcdn.com/v/14.0.2/svg/1f389.svg)


## User sessions

### Remembering logged-in users

- When they sign up or authenticate, store their user_id in the session:

demo/good_password/app.py
```python
@app.route("/login", methods=["GET", "POST"])
def login():
    """Produce login form or handle login."""

    form = LoginForm()

    if form.validate_on_submit():
        name = form.username.data
        pwd = form.password.data

        # authenticate will return a user or False
        user = User.authenticate(name, pwd)

        if user:
            session["user_id"] = user.id  # keep logged in
            return redirect("/secret")

        else:
            form.username.errors = ["Bad name/password"] # error code provided

    return render_template("login.html", form=form)
```

### Keeping user logged in

- Anywhere: you can check if user_id is in session:

demo/good_password/templates/index.html
```html
  {% if 'user_id' in session %}   <!-- Can do this in jinja b/c 'Session' is passed to jinja automatically -->
    <li><a href="/logout">Logout</a></li>
    <li><a href="/secret">Secret</a></li>

    <form action="/logout" method="POST">
      {{form.hidden_tag()}}
      <button type="submit" class="btn btn-primary">Logout</button>
    </form>
  {% endif %}
```

### Ensuring users are authorized

- On any “protected” or “secret” route…
	- & Can trust session because it is *signed*

demo/good_password/app.py
```python
@app.get("/secret")
def secret():
    """Example hidden page for logged-in users only."""

    if "user_id" not in session:
        flash("You must be logged in to view!")
        return redirect("/")

    else:
        return render_template("secret.html")
```

- & Alternatively, can raised Unauthorized() error:
```python
from werkzeug.exceptions import Unauthorized

@app.get("/secret")
def secret():
    """Example hidden page for logged-in users only."""

    if "user_id" not in session:
        raise Unauthorized()

    else:
        return render_template("secret.html")
```

### Logging out

- Remove user_id from the session.
- & Want logout to be a *POST* request always:
	- Cause GET requests don’t have a good way to do CSRF
	- GET requests can be cached, and you want to make sure the logout request actually gets to the server.
- & Also need to make sure we’re protected against CSRF within this POST route too

demo/good_password/app.py
```python
@app.post("/logout")
def logout():
    """Logs user out and redirects to homepage."""

    form = CSRFProtectForm()

    if form.validate_on_submit():
        # Remove "user_id" if present, but no errors if it wasn't
        session.pop("user_id", None)

    return redirect("/")
```

demo/good_password/forms.py
```python
class CSRFProtectForm(FlaskForm):
    """Form just for CSRF Protection"""
```
- & CSRF form does not need any fields, just need a form to instantiate within the route to enable CSRF protection.
- & Additionally need the “logout” button to be contained within a HTML form, and ensure that form has a: 
   `{{ form.hidden_tag() }}` 
	- `form.hidden_tag()` shows all things that would be hidden. If CSRF is the only hidden thing, `csrf_token` does the same thing for that purpose.
